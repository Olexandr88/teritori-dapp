use cosmwasm_std::{Attribute, HexBinary, Uint128};
use cw2981_royalties::{Metadata, Trait};
use cw721::{Approval, ContractInfoResponse};
use cw_multi_test::AppResponse;
use rs_merkle::{Hasher, MerkleProof, MerkleTree};
use sylvia::multitest::App;

use crate::{
    contract::{sv::multitest_utils::CodeId, Config, ContractVersion, Tr721InstantiateMsg},
    error::ContractError,
    hasher::TrKeccak256,
    utils::serialize_metadata,
};

const CREATOR: &str = "creator_user";
const MINTER: &str = "minter_user";
const OWNER: &str = "owner_user";
const OPERATOR: &str = "operator_user";
const UNAUTHOR: &str = "unauthor_user";

const ROYALTY_ADDR: &str = "royalty_addr";

// Generated by merke root later in the code
const MERKLE_ROOT: &str = "9d1e9227fafa364ffb2c4311c0b57a38498babfede1c39338699c084dc7f5ff4";

const FIRST_TOKEN_ID: &str = "1";

fn has_attr(given_attrs: &Vec<Attribute>, expected_attr: &Attribute) -> bool {
    let resp = given_attrs
        .iter()
        .find(|item| item.key == expected_attr.key && item.value == expected_attr.value);
    resp.is_some()
}

fn assert_wasm_attr(resp: AppResponse, expected_attr: Attribute) {
    // app.events[0]: exec events
    // app.events[1]: wasm events
    let wasm_attrs = &resp.events[1].attributes;

    if !has_attr(wasm_attrs, &expected_attr) {
        panic!(
            "Attribute not found. Wasm attrs: {:?} - Expected attr: {:?}",
            wasm_attrs, expected_attr
        )
    }
}

#[test]
fn full_flow() {
    // 1. Create
    let app: App<sylvia::cw_multi_test::App> = App::default();

    // Instantiate NFT contract ---------------------------------------------------------
    let contract = CodeId::store_code(&app)
        .instantiate(Tr721InstantiateMsg {
            name: "NFT name".to_string(),
            symbol: "SYMBOL".to_string(),
            minter: MINTER.to_string(),
            config: Config {
                merkle_root: MERKLE_ROOT.to_string(),
                total_supply: 4,
            },
        })
        .call(CREATOR)
        .unwrap();

    // Query minter
    {
        let resp = contract.minter().unwrap();
        assert_eq!(resp.minter, Some(MINTER.to_string()));
    }

    // Query contract info
    {
        let resp = contract.contract_info().unwrap();
        assert_eq!(
            resp,
            ContractInfoResponse {
                name: "NFT name".to_string(),
                symbol: "SYMBOL".to_string()
            }
        );
    }

    // Mint NFT with metadata onchain + royalty address and query NFT info
    {
        let token_id = FIRST_TOKEN_ID.to_string();
        let owner = OWNER.to_string();
        let token_uri = Some("token_uri".to_string());
        let extention = Some(Metadata {
            name: Some("this is NFT name".to_string()),
            royalty_payment_address: Some(ROYALTY_ADDR.to_string()),
            royalty_percentage: Some(5), // royalty 5%

            ..Metadata::default()
        });
        contract
            .mint(token_id, owner, token_uri, extention)
            .call(MINTER)
            .unwrap();

        let resp = contract.nft_info(FIRST_TOKEN_ID.to_string()).unwrap();
        let ext = resp.extension.unwrap();

        assert_eq!(ext.name, Some("this is NFT name".to_string()));
        assert_eq!(ext.royalty_payment_address, Some(ROYALTY_ADDR.to_string()));

        // Query balance
    }

    // Query All NFT info
    {
        let resp = contract
            .all_nft_info(FIRST_TOKEN_ID.to_string(), Some(true))
            .unwrap();
        assert_eq!(resp.info.token_uri, Some("token_uri".to_string()));
    }

    // Query owner of
    {
        let resp = contract
            .owner_of(FIRST_TOKEN_ID.to_string(), Some(true))
            .unwrap();
        assert_eq!(resp.owner, OWNER.to_string());
    }

    // Approve
    {
        let resp = contract
            .approve(OPERATOR.to_string(), FIRST_TOKEN_ID.to_string(), None)
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp,
            Attribute {
                key: "spender".to_string(),
                value: OPERATOR.to_string(),
            },
        );
    }

    // Approve all
    {
        let resp = contract
            .approve_all(OPERATOR.to_string(), None)
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp,
            Attribute {
                key: "operator".to_string(),
                value: OPERATOR.to_string(),
            },
        );
    }

    // Query operator
    {
        let resp = contract
            .operator(OWNER.to_string(), OPERATOR.to_string(), Some(false))
            .unwrap();
        assert_eq!(
            resp.approval,
            Approval {
                spender: OPERATOR.to_string(),
                expires: cw721::Expiration::Never {}
            }
        )
    }

    // Check royalties
    {
        let resp = contract.check_royalties().unwrap();
        assert_eq!(resp.royalty_payments, true)
    }

    // Query royalties info
    {
        let resp = contract
            .royalty_info(FIRST_TOKEN_ID.to_string(), Uint128::new(1000))
            .unwrap();
        assert_eq!(resp.royalty_amount, Uint128::new(50))
    }

    // Query contract version
    {
        let resp = contract.contract_version().unwrap();
        assert_eq!(
            resp,
            ContractVersion {
                contract: "teritori:nft-tr721".to_string(),
                version: "0.1.0".to_string()
            }
        )
    }

    // Request mint: expected token_id = 2
    {
        let resp = contract.request_mint().call(OWNER).unwrap();
        assert_wasm_attr(
            resp.to_owned(),
            Attribute {
                key: "token_id".to_string(),
                value: "2".to_string(),
            },
        );
        assert_wasm_attr(
            resp,
            Attribute {
                key: "owner".to_string(),
                value: OWNER.to_string(),
            },
        );

        // Requested mint but nft does not exist yet
        let not_found_err = contract.nft_info("2".to_string()).unwrap_err();
        assert!(not_found_err.to_string().contains("not found"))
    }

    // Query merke root
    {
        let resp = contract.merkle_root().unwrap();
        assert_eq!(resp, MERKLE_ROOT.to_string())
    }

    // Test merkle tree
    {
        let leaf_values = ["a", "b", "c", "d", "e", "f"];
        let leaves: Vec<[u8; 32]> = leaf_values
            .iter()
            // .map(|x| Sha256::digest(x).try_into().unwrap())
            .map(|x| TrKeccak256::hash(x.as_bytes()))
            .collect();

        let idx = 1;

        let merkle_tree = MerkleTree::<TrKeccak256>::from_leaves(&leaves);

        let leaf_indices = vec![idx];
        let leaf_hashes = leaves.get(idx..idx + 1).unwrap();

        let merkle_proof = merkle_tree.proof(&leaf_indices);

        let merkle_root = merkle_tree.root().unwrap();

        let proof_bytes = merkle_proof.to_bytes();
        let proof_hex = HexBinary::from(proof_bytes.to_owned()).to_string();
        let proof_bytes_from_hex = HexBinary::from_hex(&proof_hex).unwrap().to_vec();

        // panic!("proof_bytes: {:?}, proof_bytes_from_hex: {:?}", proof_bytes, proof_bytes_from_hex);

        let proof = MerkleProof::<TrKeccak256>::try_from(proof_bytes_from_hex.to_owned()).unwrap();

        let is_ok = proof.verify(merkle_root, &leaf_indices, leaf_hashes, leaves.len());
        assert!(is_ok);

        let root_hex = HexBinary::from(merkle_root).to_string();
        let root_from_hex: [u8; 32] = HexBinary::from_hex(root_hex.as_str())
            .unwrap()
            .to_vec()
            .try_into()
            .unwrap();

        assert!(merkle_root == root_from_hex);
        // panic!("hex: {}, proof_hex: {}, root from hex: {:X?}, Is OK: {}, Root: {:X?}, Is equal: {}", root_hex, proof_hex, root_from_hex, is_ok, merkle_root, merkle_root == root_from_hex);
    }

    // Test mint with merkle path
    {
        let nft0 = Metadata {
            name: Some("nft #0".to_string()),
            image: Some("image0".to_string()),
            attributes: Some(vec![Trait {
                display_type: Some("attr0".to_string()),
                trait_type: "type0".to_string(),
                value: "value0".to_string(),
            }]),
            ..Metadata::default()
        };
        let nft1 = Metadata {
            name: Some("nft #1".to_string()),
            image: Some("image1".to_string()),
            attributes: Some(vec![Trait {
                display_type: Some("attr1".to_string()),
                trait_type: "type1".to_string(),
                value: "value1".to_string(),
            }]),
            ..Metadata::default()
        };
        let nft2 = Metadata {
            name: Some("nft #2".to_string()),
            image: Some("image2".to_string()),
            attributes: Some(vec![Trait {
                display_type: Some("attr2".to_string()),
                trait_type: "type2".to_string(),
                value: "value2".to_string(),
            }]),
            ..Metadata::default()
        };
        let nft3 = Metadata {
            name: Some("nft #3".to_string()),
            image: Some("image3".to_string()),
            attributes: Some(vec![Trait {
                display_type: Some("attr3".to_string()),
                trait_type: "type3".to_string(),
                value: "value3".to_string(),
            }]),
            ..Metadata::default()
        };

        let nfts = vec![nft0, nft1, nft2.clone(), nft3];
        let nft_hashes: Vec<[u8; 32]> = nfts
            .iter()
            .map(|x| TrKeccak256::hash(&serialize_metadata(x).as_bytes()))
            .collect();

        let merkle_tree = MerkleTree::<TrKeccak256>::from_leaves(&nft_hashes);
        let merkle_root = merkle_tree.root().unwrap();
        let root_hex = HexBinary::from(merkle_root).to_string();

        assert_eq!(root_hex, MERKLE_ROOT.to_string());

        // Try to claim un-requested token
        let not_requested_err = contract
            .claim(
                "inexist".to_string(),
                Metadata::default(),
                "merkle_proof".to_string(),
            )
            .call(OWNER)
            .unwrap_err();
        assert_eq!(not_requested_err, ContractError::NftNotRequested);

        // Claim a registed token from unauthorized user
        let unauthor_claim_err = contract
            .claim(
                "2".to_string(),
                Metadata::default(),
                "merkle_proof".to_string(),
            )
            .call(UNAUTHOR)
            .unwrap_err();
        assert_eq!(unauthor_claim_err, ContractError::Unauthorized);

        // Claim registered token from correct owner => should be successull
        let leaf_indices = vec![2];
        let merkle_proof = merkle_tree.proof(&leaf_indices);
        let proof_bytes = merkle_proof.to_bytes();
        let proof_hex = HexBinary::from(proof_bytes.to_owned()).to_string();

        let resp = contract
            .claim("2".to_string(), nft2.clone(), proof_hex)
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp.clone(),
            Attribute {
                key: "action".to_string(),
                value: "claim".to_string(),
            },
        );
        assert_wasm_attr(
            resp.clone(),
            Attribute {
                key: "token_id".to_string(),
                value: "2".to_string(),
            },
        );

        // At this step, token should exist and mint
        let resp = contract.nft_info("2".to_string()).unwrap();
        assert_eq!(resp.token_uri, None);
        assert_eq!(resp.extension.unwrap().name, nft2.name);
    }
}
