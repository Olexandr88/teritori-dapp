use cosmwasm_std::{coin, Addr, Attribute, HexBinary, Uint128};
use cw2981_royalties::Metadata;
use cw721::{Approval, ContractInfoResponse};
use rs_merkle::{Hasher, MerkleProof, MerkleTree};
use sylvia::multitest::App;

use crate::{
    contract::{
        sv::multitest_utils::CodeId, ContractVersion, MintInfo, WhitelistMintInfo, WhitelistProof,
    },
    error::ContractError,
    hasher::TrKeccak256,
    test_helpers::{
        assert_wasm_attr, get_default_mint_info, get_default_nfts,
        get_default_whitelist_mint_infos, get_merkle_tree, get_merkle_tree_info,
        DEFAULT_BLOCK_TIME, MERKLE_ROOT,
    },
    utils::proto_encode,
};

const ADMIN: &str = "admin_user";
const CREATOR: &str = "creator_user";
const MINTER: &str = "minter_user";
const OWNER: &str = "owner_user";
const OPERATOR: &str = "operator_user";
const UNAUTHOR: &str = "unauthor_user";
const ROYALTY_ADDR: &str = "royalty_addr";

// Generated by merke root later in the code
const FIRST_TOKEN_ID: &str = "1";

#[test]
fn full_flow() {
    // 1. Create
    let app: App<sylvia::cw_multi_test::App> = App::default();

    app.app_mut()
        .init_modules(|router, _, storage| {
            router.bank.init_balance(
                storage,
                &Addr::unchecked(OWNER.to_string()),
                vec![coin(1000000, "utori"), coin(1000000, "uinvalid")],
            )?;
            Ok::<(), sylvia::anyhow::Error>(())
        })
        .unwrap();

    // Instantiate NFT contract ---------------------------------------------------------
    let mint_info = get_default_mint_info();
    let whitelist_mint_infos = get_default_whitelist_mint_infos();
    let contract = CodeId::store_code(&app)
        .instantiate(
            ADMIN.to_string(),
            "NFT name".to_string(),
            MINTER.to_string(),
            "SYMBOL".to_string(),
            "launchpad_contract".to_string(),
            mint_info,
            whitelist_mint_infos,
        )
        .call(CREATOR)
        .unwrap();

    // Query minter
    {
        let resp = contract.minter().unwrap();
        assert_eq!(resp.minter, Some(MINTER.to_string()));
    }

    // Query contract info
    {
        let resp = contract.contract_info().unwrap();
        assert_eq!(
            resp,
            ContractInfoResponse {
                name: "NFT name".to_string(),
                symbol: "SYMBOL".to_string()
            }
        );
    }

    // Query mint info
    {
        let resp = contract.mint_info().unwrap();
        assert_eq!(resp.tokens_count, 4);
        assert_eq!(resp.merkle_root, MERKLE_ROOT.to_string());
    }

    // Query whitelist mint
    {
        let resp = contract.whitelist_mint_infos().unwrap();
        assert_eq!(resp, get_default_whitelist_mint_infos());
    }

    // Mint NFT with metadata onchain + royalty address and query NFT info
    {
        let token_id = FIRST_TOKEN_ID.to_string();
        let owner = OWNER.to_string();
        let token_uri = Some("token_uri".to_string());
        let extention = Some(Metadata {
            name: Some("this is NFT name".to_string()),
            royalty_payment_address: Some(ROYALTY_ADDR.to_string()),
            royalty_percentage: Some(5), // royalty 5%

            ..Metadata::default()
        });
        contract
            .mint(token_id, owner, token_uri, extention)
            .call(MINTER)
            .unwrap();

        let resp = contract.nft_info(FIRST_TOKEN_ID.to_string()).unwrap();
        let ext = resp.extension.unwrap();

        assert_eq!(ext.name, Some("this is NFT name".to_string()));
        assert_eq!(ext.royalty_payment_address, Some(ROYALTY_ADDR.to_string()));

        // Query balance
    }

    // Query All NFT info
    {
        let resp = contract
            .all_nft_info(FIRST_TOKEN_ID.to_string(), Some(true))
            .unwrap();
        assert_eq!(resp.info.token_uri, Some("token_uri".to_string()));
    }

    // Query owner of
    {
        let resp = contract
            .owner_of(FIRST_TOKEN_ID.to_string(), Some(true))
            .unwrap();
        assert_eq!(resp.owner, OWNER.to_string());
    }

    // Approve
    {
        let resp = contract
            .approve(OPERATOR.to_string(), FIRST_TOKEN_ID.to_string(), None)
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp,
            Attribute {
                key: "spender".to_string(),
                value: OPERATOR.to_string(),
            },
        );
    }

    // Approve all
    {
        let resp = contract
            .approve_all(OPERATOR.to_string(), None)
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp,
            Attribute {
                key: "operator".to_string(),
                value: OPERATOR.to_string(),
            },
        );
    }

    // Query operator
    {
        let resp = contract
            .operator(OWNER.to_string(), OPERATOR.to_string(), Some(false))
            .unwrap();
        assert_eq!(
            resp.approval,
            Approval {
                spender: OPERATOR.to_string(),
                expires: cw721::Expiration::Never {}
            }
        )
    }

    // Check royalties
    {
        let resp = contract.check_royalties().unwrap();
        assert_eq!(resp.royalty_payments, true)
    }

    // Query royalties info
    {
        let resp = contract
            .royalty_info(FIRST_TOKEN_ID.to_string(), Uint128::new(1000))
            .unwrap();
        assert_eq!(resp.royalty_amount, Uint128::new(50))
    }

    // Query contract version
    {
        let resp = contract.contract_version().unwrap();
        assert_eq!(
            resp,
            ContractVersion {
                contract: "teritori:nft-tr721".to_string(),
                version: "0.2.0".to_string()
            }
        )
    }

    // Update mint info with unauthorized user
    {
        let mint_info = MintInfo::default();
        let err = contract
            .update_mint_info(mint_info)
            .call(UNAUTHOR)
            .unwrap_err();
        assert_eq!(err, ContractError::Unauthorized);
    }

    // Request mint: Error if reached max tokens
    {
        contract
            .update_mint_info(MintInfo::default())
            .call(ADMIN)
            .unwrap();

        assert_eq!(
            contract.request_mint(None).call(OWNER).unwrap_err(),
            ContractError::MintExceedMaxTokens
        );
    }

    // Request mint:
    // - Mint not started
    // - Not in whitelist address
    // => ContractError::MintNotStarted
    {
        contract
            .update_mint_info(MintInfo {
                tokens_count: 10,
                start_time: DEFAULT_BLOCK_TIME + 10,
                ..MintInfo::default()
            })
            .call(ADMIN)
            .unwrap();

        assert_eq!(
            contract.request_mint(None).call(OWNER).unwrap_err(),
            ContractError::MintNotStarted
        );
    }

    // Request mint:
    // - Mint not started
    // - In whitelist address but not in whitelist time
    // => ContractError::MintNotStarted
    {
        let tree = get_merkle_tree(vec![OWNER]);
        let root_hex = HexBinary::from(tree.root().unwrap()).to_string();
        contract
            .update_whitelist_mint_info(
                0,
                WhitelistMintInfo {
                    merkle_root: root_hex,
                    ..WhitelistMintInfo::default()
                },
            )
            .call(ADMIN)
            .unwrap();

        assert_eq!(
            contract.request_mint(None).call(OWNER).unwrap_err(),
            ContractError::MintNotStarted
        );
    }

    // Request mint:
    // - Mint not started
    // - In whitelist time but not in whitelist
    // => ContractError::MintNotStarted
    {
        contract
            .update_whitelist_mint_info(
                0,
                WhitelistMintInfo {
                    start_time: DEFAULT_BLOCK_TIME - 10,
                    end_time: DEFAULT_BLOCK_TIME + 10,
                    ..WhitelistMintInfo::default()
                },
            )
            .call(ADMIN)
            .unwrap();

        assert_eq!(
            contract.request_mint(None).call(OWNER).unwrap_err(),
            ContractError::MintNotStarted
        );
    }

    // Request mint:
    // - Mint not started
    // - In whitelist time and in whitelist
    // - Reach max per whitelist user
    // => ContractError::WhitelistMintExceedMaxPerUser
    {
        let (root_hex, proof_hex) = get_merkle_tree_info(vec![UNAUTHOR, OWNER], 1);

        contract
            .update_whitelist_mint_info(
                0,
                WhitelistMintInfo {
                    merkle_root: root_hex,
                    addresses_count: 2,
                    start_time: DEFAULT_BLOCK_TIME - 10,
                    end_time: DEFAULT_BLOCK_TIME + 10,
                    ..WhitelistMintInfo::default()
                },
            )
            .call(ADMIN)
            .unwrap();

        assert_eq!(
            contract
                .request_mint(Some(WhitelistProof {
                    merkle_proof: proof_hex,
                    address_indice: 1,
                }))
                .call(OWNER)
                .unwrap_err(),
            ContractError::WhitelistMintExceedMaxPerUser
        );
    }

    // Request mint:
    // - Mint not started
    // - In whitelist time and in whitelist
    // - Not Reach max per whitelist user
    //
    // => Not send fund: ContractError::InvalidFund
    // => Not send valid denom: ContractError::InvalidDenom
    // => Not send valid amount: ContractError::InvalidAmount
    {
        let (root_hex, proof_hex) = get_merkle_tree_info(vec!["addr0", "addr1", "addr2", "addr3", "addr4", OWNER], 5);
        contract
            .update_whitelist_mint_info(
                0,
                WhitelistMintInfo {
                    limit_per_address: 10,
                    unit_price: Uint128::new(10),
                    denom: "utori".to_string(),
                    merkle_root: root_hex,
                    addresses_count: 6,
                    start_time: DEFAULT_BLOCK_TIME - 10,
                    end_time: DEFAULT_BLOCK_TIME + 10,
                    ..WhitelistMintInfo::default()
                },
            )
            .call(ADMIN)
            .unwrap();

        let whitelist_proof = Some(WhitelistProof {
            merkle_proof: proof_hex,
            address_indice: 5
        });

        assert_eq!(
            contract
                .request_mint(whitelist_proof.to_owned())
                .call(OWNER)
                .unwrap_err(),
            ContractError::InvalidFund
        );

        assert_eq!(
            contract
                .request_mint(whitelist_proof.to_owned())
                .with_funds(&[coin(10, "uinvalid")])
                .call(OWNER)
                .unwrap_err(),
            ContractError::InvalidDenom
        );

        assert_eq!(
            contract
                .request_mint(whitelist_proof.to_owned())
                .with_funds(&[coin(1, "utori")])
                .call(OWNER)
                .unwrap_err(),
            ContractError::InvalidAmount
        );
    }

    // Request mint: with the mint/whitelist info in previous step
    // but with correct fund this time => mint successfully
    {
        let (_, proof_hex) = get_merkle_tree_info(vec!["addr0", "addr1", "addr2", "addr3", "addr4", OWNER], 5);
        let whitelist_proof = Some(WhitelistProof {
            merkle_proof: proof_hex,
            address_indice: 5
        });
        let resp = contract
            .request_mint(whitelist_proof)
            .with_funds(&[coin(10, "utori")])
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp.to_owned(),
            Attribute {
                key: "token_id".to_string(),
                value: "2".to_string(),
            },
        );

        let total_minted = contract.total_minted().unwrap();
        assert_eq!(total_minted, 2); // We have already minted by minter previously

        let minted_by_user = contract.minted_count_by_user(OWNER.to_string()).unwrap();
        assert_eq!(minted_by_user, 0);

        let whitelist_minted_by_user = contract
            .whitelist_minted_count_by_user(0, OWNER.to_string())
            .unwrap();
        assert_eq!(whitelist_minted_by_user, 1);
    }

    // Request mint: normal mint
    // - Reached max token per user
    // => ContractError::MintExceedMaxPerUser
    {
        contract
            .update_whitelist_mint_info(0, WhitelistMintInfo::default())
            .call(ADMIN)
            .unwrap();

        contract
            .update_mint_info(MintInfo {
                tokens_count: 10,
                start_time: DEFAULT_BLOCK_TIME - 10,
                ..MintInfo::default()
            })
            .call(ADMIN)
            .unwrap();

        assert_eq!(
            contract.request_mint(None).call(OWNER).unwrap_err(),
            ContractError::MintExceedMaxPerUser
        );
    }

    // Request mint: normal mint
    // - Not Reached max token per user
    // - Send correct fund
    // => success
    {
        contract
            .update_whitelist_mint_info(0, WhitelistMintInfo::default())
            .call(ADMIN)
            .unwrap();

        contract
            .update_mint_info(MintInfo {
                tokens_count: 4,
                limit_per_address: 10,
                denom: "utori".to_string(),
                unit_price: Uint128::new(10),
                start_time: DEFAULT_BLOCK_TIME - 10,
                ..MintInfo::default()
            })
            .call(ADMIN)
            .unwrap();

        let resp = contract
            .request_mint(None)
            .with_funds(&[coin(10, "utori")])
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp,
            Attribute {
                key: "token_id".to_string(),
                value: "3".to_string(),
            },
        );

        let total_minted = contract.total_minted().unwrap();
        assert_eq!(total_minted, 3);

        let minted_by_user = contract.minted_count_by_user(OWNER.to_string()).unwrap();
        assert_eq!(minted_by_user, 1);

        let whitelist_minted_by_user = contract
            .whitelist_minted_count_by_user(0, OWNER.to_string())
            .unwrap();
        assert_eq!(whitelist_minted_by_user, 1);
    }

    // Query merke root
    {
        contract
            .update_mint_info(get_default_mint_info())
            .call(ADMIN)
            .unwrap();

        let resp = contract.merkle_root().unwrap();
        assert_eq!(resp, MERKLE_ROOT.to_string())
    }

    // Test merkle tree
    {
        let leaf_values = ["addr1", "addr2", "addr3", "addr4", "add5"];
        let leaves: Vec<[u8; 32]> = leaf_values
            .iter()
            .map(|x| TrKeccak256::hash(x.as_bytes()))
            .collect();

        let idx = 1;

        let merkle_tree = MerkleTree::<TrKeccak256>::from_leaves(&leaves);

        let leaf_indices = vec![idx];
        let leaf_hashes = leaves.get(idx..idx + 1).unwrap();

        let merkle_proof = merkle_tree.proof(&leaf_indices);

        let merkle_root = merkle_tree.root().unwrap();

        let proof_bytes = merkle_proof.to_bytes();
        let proof_hex = HexBinary::from(proof_bytes.to_owned()).to_string();
        let proof_bytes_from_hex = HexBinary::from_hex(&proof_hex).unwrap().to_vec();

        let proof = MerkleProof::<TrKeccak256>::try_from(proof_bytes_from_hex.to_owned()).unwrap();

        let is_ok = proof.verify(merkle_root, &leaf_indices, leaf_hashes, leaves.len());
        assert!(is_ok);

        let root_hex = HexBinary::from(merkle_root).to_string();
        let root_from_hex: [u8; 32] = HexBinary::from_hex(root_hex.as_str())
            .unwrap()
            .to_vec()
            .try_into()
            .unwrap();

        assert!(merkle_root == root_from_hex);
        // panic!("hex: {}, proof_hex: {}, root from hex: {:X?}, Is OK: {}, Root: {:X?}, Is equal: {}", root_hex, proof_hex, root_from_hex, is_ok, merkle_root, merkle_root == root_from_hex);
    }

    // Test mint with merkle path
    {
        let nfts = get_default_nfts();
        let nft2 = &nfts[2];
        let nft_hashes: Vec<[u8; 32]> = nfts
            .iter()
            .map(|x| TrKeccak256::hash(&proto_encode(x)))
            .collect();

        let merkle_tree = MerkleTree::<TrKeccak256>::from_leaves(&nft_hashes);
        let merkle_root = merkle_tree.root().unwrap();
        let root_hex = HexBinary::from(merkle_root).to_string();

        assert_eq!(root_hex, MERKLE_ROOT.to_string());

        // Try to claim un-requested token
        let not_requested_err = contract
            .claim(
                "inexist".to_string(),
                Metadata::default(),
                "merkle_proof".to_string(),
            )
            .call(OWNER)
            .unwrap_err();
        assert_eq!(not_requested_err, ContractError::NftNotRequested);

        // Claim a registed token from unauthorized user
        let unauthor_claim_err = contract
            .claim(
                "2".to_string(),
                Metadata::default(),
                "merkle_proof".to_string(),
            )
            .call(UNAUTHOR)
            .unwrap_err();
        assert_eq!(unauthor_claim_err, ContractError::Unauthorized);

        // Claim registered token from correct owner => should be successull
        let leaf_indices = vec![2];
        let merkle_proof = merkle_tree.proof(&leaf_indices);
        let proof_bytes = merkle_proof.to_bytes();
        let proof_hex = HexBinary::from(proof_bytes.to_owned()).to_string();

        let resp = contract
            .claim("2".to_string(), nft2.clone(), proof_hex)
            .call(OWNER)
            .unwrap();

        assert_wasm_attr(
            resp.clone(),
            Attribute {
                key: "action".to_string(),
                value: "claim".to_string(),
            },
        );
        assert_wasm_attr(
            resp.clone(),
            Attribute {
                key: "token_id".to_string(),
                value: "2".to_string(),
            },
        );

        // At this step, token should exist and mint
        let resp = contract.nft_info("2".to_string()).unwrap();
        assert_eq!(resp.token_uri, None);
        assert_eq!(resp.extension.unwrap().name, nft2.name);
    }

    // Claim a token: (generated from golang backend)
    {}
}
